{"0": {
    "doc": "Aggregates",
    "title": "Aggregates",
    "content": "Events that are captured, stored in Aggregates. As their name implies, they aggregate in once place, events that belong to the same entity. In order to easily locate an aggregate, it has an Aggregate Type and an Aggregate Id. The combination of both need to be unique across the system. For example, you can define an aggregate of type user with an id of john. Now you can store all events that belong to the user “John” in that aggregates. When you ask Eventualize to read the state of an aggregate, in principal what it does is fetching all the aggregate’s events and “folding” them one on top of the other to derive the current state. Folding means taking a sequence of events and based on their content perform an aggregative calculation. So when a service wants to read the state of an aggregate, it needs to provide to Eventualize the identification of the aggregate in terms of Aggregate Type and Aggregate ID, and a Folding Logic, which is the mapping between an Event Type and the function that holds the desired calculation of its content. That means that you can read the same aggregate using different folding logics, and derive different states from the same data! . Another important advantage of this approach is the it provides strong consistency when reading an aggregates’s state. Because immediately after strong an event, you’ll be able to read an up-to-date state of the aggregate that includes that event! . However in order to use it in large scale production systems there are 2 more important considerations: . | Read Time - What if there are many events in an aggregate? Wouldn’t reading all of them in order to derive the state take a long time? For that we have Snaphots. | Strong Consistency with Writes - How can an service or application store an event, only if the state hasn’t changed since tha last time it was read? For that we have Optimistic Concurrency Control. | . ",
    "url": "/learn-more/aggregates.html",
    
    "relUrl": "/learn-more/aggregates.html"
  },"1": {
    "doc": "Code Contribution",
    "title": "Code Contribution",
    "content": " ",
    "url": "/contribution/code-contribution.html",
    
    "relUrl": "/contribution/code-contribution.html"
  },"2": {
    "doc": "Code Contribution",
    "title": "Quick Start",
    "content": "// TODO: . | Install CLI | Create template | Spin Docker or having a connection string to cloud/on-prem DB | . docker run -e \"ACCEPT_EULA=Y\" -e \"MSSQL_SA_PASSWORD=MasadNetunim12!@\" -p 1433:1433 --name sql --hostname sql -d mcr.microsoft.com/mssql/server:2022-latest . | run tests | Run the sample code (F5) | Check the Telemetry | Manual deploy NuGet to nuget.org (first time) | CI/CD Set the permission &amp; secret (will deploy NuGet on each push) | . ",
    "url": "/contribution/code-contribution.html#quick-start",
    
    "relUrl": "/contribution/code-contribution.html#quick-start"
  },"3": {
    "doc": "Events",
    "title": "Events",
    "content": "Events are facts that happened and are of interest to the software system. In principal, anythings that is detected by the software system is an event. Events can be detected from outside of the system, for example: . | User selected a product | Third-party service sent an API request Events can be detected from within the system, for example: | Free trial period ended | User credit score updated As you can see, all the example are phrased in a past tense. This is because events are things that have already happened. | . ",
    "url": "/learn-more/events.html",
    
    "relUrl": "/learn-more/events.html"
  },"4": {
    "doc": "Events",
    "title": "Event Structure",
    "content": "In Eventualize, All events have the same structure: . | property name | data type | meaning | . | event_type | string | required. A description of the event (e.g. “user earned points”) | . | captured_at | datetime | required. The point in time in which the event was detected | . | captured_by | string | required. The name of the service that detected the event | . | payload | json | required. The data of the event (e.g. username, number of points) | . | stored_at | datetime | Optional. Populated by Eventualize after the event has been stored | . ",
    "url": "/learn-more/events.html#event-structure",
    
    "relUrl": "/learn-more/events.html#event-structure"
  },"5": {
    "doc": "Events",
    "title": "Creating a new event",
    "content": "Prerequisite . This section assumes you have installed Eventualize package in you project. If this is not the case, got to Quick Start and learn how to do that. C# . var capturedAt = DateTime.Now; var capturedBy = \"&lt;capturing service name&gt;\"; var data = new EventData(...); var newEvent = new EventEntity(capturedAt, capturedBy,data); . Now that we understand events, we can learn how they are used to derive the system’s state. Hint: this is what Aggregates are for. Let’s proceed to the Aggregates section! . ",
    "url": "/learn-more/events.html#creating-a-new-event",
    
    "relUrl": "/learn-more/events.html#creating-a-new-event"
  },"6": {
    "doc": "Learn More",
    "title": "Learn More",
    "content": "In this section you can get familiar with the Event Sourcing principal of Eentualize and how you can quickly and easly use it yourself. ",
    "url": "/learn-more/",
    
    "relUrl": "/learn-more/"
  },"7": {
    "doc": "Contribution",
    "title": "Contribution",
    "content": "Eventualize is a project that is meant to not only help integrate event sourcing on a technical level, but also change the paradaigm in which we all think about software systems. There are plenty of ways you can assist us in our mission. Here are some ways that we have thought about. If you don’t find something here that feets you and would like to contribute, contact us at TODO: add email address. ",
    "url": "/contribution/",
    
    "relUrl": "/contribution/"
  },"8": {
    "doc": "Home",
    "title": "Eventualize",
    "content": ". Eventualize is an opinionated event-sourcing framework that unlocks the untapped potential of transactional data while eliminating many challenges related to management of transactional data and its schema. Eventualize is quick &amp; easy to integrate, and while it is working with new paradigms and patterns under the hood, it abstracts most of it away and does not distrupt development. ",
    "url": "/#eventualize",
    
    "relUrl": "/#eventualize"
  },"9": {
    "doc": "Home",
    "title": "Quick Start",
    "content": "If you want to jump right into it, go to Quick Start . ",
    "url": "/#quick-start",
    
    "relUrl": "/#quick-start"
  },"10": {
    "doc": "Home",
    "title": "Learn More",
    "content": "If you want to learn more, go to Learn More. ",
    "url": "/#learn-more",
    
    "relUrl": "/#learn-more"
  },"11": {
    "doc": "Home",
    "title": "Contribute",
    "content": "You can contribute to this project in many ways (not just coding)! If you are interested to learn more about how you can do this, please visit the Contribution page. ",
    "url": "/#contribute",
    
    "relUrl": "/#contribute"
  },"12": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"13": {
    "doc": "Optimistic Concurrency Control (OCC)",
    "title": "Optimistic Concurrency Control (OCC)",
    "content": " ",
    "url": "/learn-more/occ.html",
    
    "relUrl": "/learn-more/occ.html"
  },"14": {
    "doc": "Quick Start",
    "title": "Quick Start",
    "content": " ",
    "url": "/quick-start.html",
    
    "relUrl": "/quick-start.html"
  },"15": {
    "doc": "Snapshots",
    "title": "Snapshots",
    "content": " ",
    "url": "/learn-more/snapshots.html",
    
    "relUrl": "/learn-more/snapshots.html"
  },"16": {
    "doc": "Snapshots",
    "title": "Making Folding Logic Run Fast and Efficiently",
    "content": " ",
    "url": "/learn-more/snapshots.html#making-folding-logic-run-fast-and-efficiently",
    
    "relUrl": "/learn-more/snapshots.html#making-folding-logic-run-fast-and-efficiently"
  },"17": {
    "doc": "Why Should I Use It?",
    "title": "Why Should I Use It?",
    "content": "In most production applications, transactional data is captured and used to update the state of the system. Here is such an example for a application that updates the amount of points a user has: . The application updates the state of the relevant user record by increasing the points of the user with the additional points: . It’s great for keeping track of the overall points each user has. However, each time we update users points, we overwrite the previous amount of points they had. What if down the line we’d like to see the average number of daily points that earned by the user? Oh… shoot. Too bad we didn’t store the previous amounts in the first place. But that is just it! You can’t anticipate all the things you’d like to do with your data. And along the way you are bound to encounter new data driven questions you haven’t thought of when you were just starting out. Eventualize solves this by storing the actual facts that the system captured over time. We call those Events. So, following the previous example, working with Eventualize in pricnciple looks something like this: . We have captured the fact itself (user 5 earned 5 points): . This is great, beacuse now we can calculate many different things based on these events, without changing the way you store the data. All we need to do is scan of the relevant events that were captured and are related to the user, and aggregate them into the state we are interested in. We call this kind of aggregation a folding logic, and you can have multiple floding logics for the same events in order to derive diiferent states for the system. So, continuing our example, getting the information we want would something like this: . Total amount of points: . Average points per earning: . It’s that easy. Each round node that use saw above is a folding logic, and each box after that node is the resulting state. At this points you probably have some questions. Like: ‘What happens when there are many events that need to be scanned? Wouldn’t that take too long and hurt performance?’ ‘What if the events are stored in the wrong order?’ and many more. There are several mechanisms that needs to be put in place in order for event sourcing to work not only in principal but also in real life. This is why we have built Eventualize - so you wouldn’t have to! The next sections should give you a pretty good understanding on how it all works. So let’s go to the next section! . ",
    "url": "/learn-more/why-should-i-use-it.html",
    
    "relUrl": "/learn-more/why-should-i-use-it.html"
  }
}
